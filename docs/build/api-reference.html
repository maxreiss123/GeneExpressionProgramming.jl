<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · GeneExpressionProgramming.jl</title><meta name="title" content="API Reference · GeneExpressionProgramming.jl"/><meta property="og:title" content="API Reference · GeneExpressionProgramming.jl"/><meta property="twitter:title" content="API Reference · GeneExpressionProgramming.jl"/><meta name="description" content="Documentation for GeneExpressionProgramming.jl."/><meta property="og:description" content="Documentation for GeneExpressionProgramming.jl."/><meta property="twitter:description" content="Documentation for GeneExpressionProgramming.jl."/><meta property="og:url" content="https://maxreiss123.github.io/GeneExpressionProgramming.jl/api-reference.html"/><meta property="twitter:url" content="https://maxreiss123.github.io/GeneExpressionProgramming.jl/api-reference.html"/><link rel="canonical" href="https://maxreiss123.github.io/GeneExpressionProgramming.jl/api-reference.html"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">GeneExpressionProgramming.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">User Guide</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="installation.html">Installation</a></li><li><a class="tocitem" href="getting-started.html">Getting Started</a></li><li><a class="tocitem" href="core-concepts.html">Core Concepts</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="examples/basic-regression.html">Basic Regression</a></li><li><a class="tocitem" href="examples/multi-objective.html">Multi-Objective Optimization</a></li><li><a class="tocitem" href="examples/physical-dimensions.html">Physical Dimensionality</a></li><li><a class="tocitem" href="examples/tensor-regression.html">Tensor Regression</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href="api-reference.html">API Reference</a><ul class="internal"><li><a class="tocitem" href="#Core-Types"><span>Core Types</span></a></li><li><a class="tocitem" href="#Core-Functions"><span>Core Functions</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Loss-Functions"><span>Loss Functions</span></a></li><li><a class="tocitem" href="#Selection-Methods"><span>Selection Methods</span></a></li><li><a class="tocitem" href="#Genetic-Operators"><span>Genetic Operators</span></a></li><li><a class="tocitem" href="#Function-Sets"><span>Function Sets</span></a></li><li><a class="tocitem" href="#Physical-Dimensionality"><span>Physical Dimensionality</span></a></li><li><a class="tocitem" href="#Tensor-Operations-(under-construction)"><span>Tensor Operations (under construction)</span></a></li><li><a class="tocitem" href="#Error-Handling"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Performance-Tuning"><span>Performance Tuning</span></a></li><li><a class="tocitem" href="#Configuration-Examples"><span>Configuration Examples</span></a></li><li><a class="tocitem" href="#Version-Information"><span>Version Information</span></a></li><li><a class="tocitem" href="#Debugging-and-Diagnostics"><span>Debugging and Diagnostics</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href="api-reference.html">API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api-reference.html">API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maxreiss123/GeneExpressionProgramming.jl/blob/master/docs/src/api-reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This comprehensive API reference provides detailed documentation for all public functions, types, and modules in GeneExpressionProgramming.jl. The API is organized by functionality to help you quickly find the components you need.</p><h2 id="Core-Types"><a class="docs-heading-anchor" href="#Core-Types">Core Types</a><a id="Core-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types" title="Permalink"></a></h2><h3 id="GepRegressor"><a class="docs-heading-anchor" href="#GepRegressor">GepRegressor</a><a id="GepRegressor-1"></a><a class="docs-heading-anchor-permalink" href="#GepRegressor" title="Permalink"></a></h3><p>The main regressor for scalar symbolic regression tasks.</p><pre><code class="language-julia hljs">GepRegressor(number_features::Int; kwargs...)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>number_features::Int</code>: Number of input features</li><li><code>gene_count::Int = 2</code>: Number of genes per chromosome</li><li><code>head_len::Int = 7</code>: Head length of each gene</li><li><code>rnd_count::Int = 5</code>: Amount of random numbers being considered  </li><li><code>entered_non_terminals::Vector{Symbol} = [:+, :-, :*, :/]</code>: Available functions</li><li><code>gene_connections::Vector{Symbol} = [:+, :-, :*, :/]</code>: Functions for connecting the genes</li><li><code>number_of_objectives::Int = 1</code>: Number of objectives (1 for single-objective)</li><li><code>considered_dimensions::Dict{Symbol,Vector{Float16}} = Dict()</code>: Physical dimensions</li><li><code>max_permutations_lib::Int = 1000</code>: Maximum permutations for dimensional analysis</li><li><code>rounds::Int = 5</code>: Tree depth for dimensional checking</li></ul><p><strong>Fields:</strong></p><ul><li><code>best_models_::Vector</code>: Best evolved models</li><li><code>fitness_history_</code>: Training history (if available)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">regressor = GepRegressor(3; 
                        gene_count=3,
                        head_len=5,
                        entered_non_terminals=[:+, :-, :*, :/, :sin, :cos])</code></pre><h3 id="GepTensorRegressor"><a class="docs-heading-anchor" href="#GepTensorRegressor">GepTensorRegressor</a><a id="GepTensorRegressor-1"></a><a class="docs-heading-anchor-permalink" href="#GepTensorRegressor" title="Permalink"></a></h3><p>Specialized regressor for tensor (vector/matrix) symbolic regression.</p><pre><code class="language-julia hljs">GepTensorRegressor(number_features::Int, gene_count::Int, head_len::Int; kwargs...)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>number_features::Int</code>: Number of input features</li><li><code>gene_count::Int</code>: Number of genes per chromosome</li><li><code>head_len::Int</code>: Head length of each gene</li><li><code>feature_names::Vector{String} = []</code>: Names for features (for interpretability)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">regressor = GepTensorRegressor(5, 2, 3; 
                              feature_names=[&quot;x1&quot;, &quot;x2&quot;, &quot;U1&quot;, &quot;U2&quot;, &quot;U3&quot;])</code></pre><h3 id="StandardRegressionStrategy"><a class="docs-heading-anchor" href="#StandardRegressionStrategy">StandardRegressionStrategy</a><a id="StandardRegressionStrategy-1"></a><a class="docs-heading-anchor-permalink" href="#StandardRegressionStrategy" title="Permalink"></a></h3><p>A strategy for evaluating standard regression tasks with typed floating-point data.</p><pre><code class="language-julia hljs">struct StandardRegressionStrategy{T&lt;:AbstractFloat} &lt;: EvaluationStrategy</code></pre><p><strong>Fields:</strong></p><ul><li><code>operators::OperatorEnum</code>: Available operators for the strategy</li><li><code>number_of_objectives::Int</code>: Number of optimization objectives</li><li><code>x_data::AbstractArray{T}</code>: Training input data</li><li><code>y_data::AbstractArray{T}</code>: Training target data</li><li><code>x_data_test::AbstractArray{T}</code>: Test input data</li><li><code>y_data_test::AbstractArray{T}</code>: Test target data</li><li><code>loss_function::Function</code>: Primary loss function</li><li><code>validation_loss_function::Function</code>: Validation loss function</li><li><code>secOptimizer::Union{Function,Nothing}</code>: Secondary optimizer (if any)</li><li><code>break_condition::Union{Function,Nothing}</code>: Condition to stop evolution</li><li><code>penalty::T</code>: Penalty value for regularization</li><li><code>crash_value::T</code>: Value assigned on evaluation failure</li></ul><p><strong>Constructor:</strong></p><pre><code class="language-julia hljs">StandardRegressionStrategy{T}(operators::OperatorEnum,
    x_data::AbstractArray,
    y_data::AbstractArray,
    x_data_test::AbstractArray,
    y_data_test::AbstractArray,
    loss_function::Function;
    validation_loss_function::Union{Nothing,Function}=nothing,
    secOptimizer::Union{Function,Nothing}=nothing,
    break_condition::Union{Function,Nothing}=nothing,
    penalty::T=zero(T),
    crash_value::T=typemax(T)) where {T&lt;:AbstractFloat}</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia hljs">strategy = StandardRegressionStrategy{Float64}(
    OperatorEnum([:+, :-, :*, :/]),
    x_train, y_train, x_test, y_test,
    mse;
    penalty=0.1,
    crash_value=Inf
)</code></pre><h3 id="GenericRegressionStrategy"><a class="docs-heading-anchor" href="#GenericRegressionStrategy">GenericRegressionStrategy</a><a id="GenericRegressionStrategy-1"></a><a class="docs-heading-anchor-permalink" href="#GenericRegressionStrategy" title="Permalink"></a></h3><p>A flexible strategy for generic regression tasks, supporting multi-objective optimization.</p><pre><code class="language-julia hljs">struct GenericRegressionStrategy &lt;: EvaluationStrategy</code></pre><p><strong>Fields:</strong></p><ul><li><code>operators::Union{OperatorEnum,Nothing}</code>: Available operators (optional)</li><li><code>number_of_objectives::Int</code>: Number of optimization objectives</li><li><code>loss_function::Function</code>: Primary loss function</li><li><code>validation_loss_function::Union{Function,Nothing}</code>: Validation loss function</li><li><code>secOptimizer::Union{Function,Nothing}</code>: Secondary optimizer (if any)</li><li><code>break_condition::Union{Function,Nothing}</code>: Condition to stop evolution</li></ul><p><strong>Constructor:</strong></p><pre><code class="language-julia hljs">GenericRegressionStrategy(operators::Union{OperatorEnum,Nothing}, number_of_objectives::Int, loss_function::Function;
    validation_loss_function::Union{Function,Nothing}=nothing,
    secOptimizer::Union{Function,Nothing}=nothing,
    break_condition::Union{Function,Nothing}=nothing)</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia hljs">strategy = GenericRegressionStrategy(
    nothing,
    2,
    multi_objective_loss;
    validation_loss_function=validate_loss
)</code></pre><h3 id="Toolbox"><a class="docs-heading-anchor" href="#Toolbox">Toolbox</a><a id="Toolbox-1"></a><a class="docs-heading-anchor-permalink" href="#Toolbox" title="Permalink"></a></h3><p>Contains parameters and operations for GEP algorithm execution.</p><pre><code class="language-julia hljs">struct Toolbox</code></pre><p><strong>Fields:</strong></p><ul><li><code>gene_count::Int</code>: Number of genes per chromosome</li><li><code>head_len::Int</code>: Head length for each gene</li><li><code>symbols::OrderedDict{Int8,Int8}</code>: Available symbols and their arities</li><li><code>gene_connections::Vector{Int8}</code>: How genes connect</li><li><code>headsyms::Vector{Int8}</code>: Symbols allowed in head</li><li><code>tailsyms::Vector{Int8}</code>: Symbols allowed in tail</li><li><code>arrity_by_id::OrderedDict{Int8,Int8}</code>: Symbol arities</li><li><code>callbacks::Dict</code>: Operation callbacks</li><li><code>nodes::OrderedDict</code>: Node definitions</li><li><code>gen_start_indices::Vector{Int}</code>: Gene start positions</li><li><code>gep_probs::Dict{String,AbstractFloat}</code>: Operation probabilities</li><li><code>fitness_reset::Tuple</code>: Default fitness values</li><li><code>preamble_syms::Vector{Int8}</code>: Preamble symbols</li><li><code>len_preamble::Int8</code>: Preamble length</li><li><code>operators_::Union{OperatorEnum,Nothing}</code>: Operator definitions</li><li><code>compile_function_::Union{Function,Nothing}</code>: Compilation function</li><li><code>tail_weights::Union{Weights,Nothing}</code>: Probability for tail symbols</li><li><code>head_weights::Union{Weights,Nothing}</code>: Probability for head symbols</li></ul><p><strong>Constructor:</strong></p><pre><code class="language-julia hljs">Toolbox(gene_count::Int, head_len::Int, symbols::OrderedDict{Int8,Int8}, 
       gene_connections::Vector{Int8}, callbacks::Dict, nodes::OrderedDict, 
       gep_probs::Dict{String,AbstractFloat};
       unary_prob::Real=0.1, preamble_syms=Int8[],
       number_of_objectives::Int=1, operators_::Union{OperatorEnum,Nothing}=nothing,
       function_complile::Union{Function,Nothing}=compile_djl_datatype,
       tail_weights_::Union{Weights,Nothing}=nothing,
       head_tail_balance::Real=0.5)</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia hljs">toolbox = Toolbox(
    3, 5, OrderedDict{Int8,Int8}(1 =&gt; 2, 2 =&gt; 0), 
    Int8[1], Dict(), OrderedDict(), Dict(&quot;mutation_prob&quot; =&gt; 0.1);
    unary_prob=0.2
)</code></pre><h3 id="Chromosome"><a class="docs-heading-anchor" href="#Chromosome">Chromosome</a><a id="Chromosome-1"></a><a class="docs-heading-anchor-permalink" href="#Chromosome" title="Permalink"></a></h3><p>Represents an individual solution in GEP.</p><pre><code class="language-julia hljs">mutable struct Chromosome</code></pre><p><strong>Fields:</strong></p><ul><li><code>genes::Vector{Int8}</code>: Genetic material</li><li><code>fitness::Tuple</code>: Fitness score</li><li><code>toolbox::Toolbox</code>: Reference to toolbox</li><li><code>compiled_function::Any</code>: Compiled expression</li><li><code>compiled::Bool</code>: Compilation status</li><li><code>expression_raw::Vector{Int8}</code>: Raw expression</li><li><code>dimension_homogene::Bool</code>: Dimensional homogeneity</li><li><code>chromo_id::Int</code>: Chromosome identifier</li></ul><p><strong>Constructor:</strong></p><pre><code class="language-julia hljs">Chromosome(genes::Vector{Int8}, toolbox::Toolbox, compile::Bool=false)</code></pre><p><strong>Example:</strong></p><pre><code class="language-julia hljs">chromosome = Chromosome(Int8[1,2,3,4,5], toolbox, true)</code></pre><h3 id="SelectedMembers"><a class="docs-heading-anchor" href="#SelectedMembers">SelectedMembers</a><a id="SelectedMembers-1"></a><a class="docs-heading-anchor-permalink" href="#SelectedMembers" title="Permalink"></a></h3><p>Represents the selected individuals obtained from NSGA-II .</p><pre><code class="language-julia hljs">struct SelectedMembers</code></pre><p><strong>Fields:</strong></p><ul><li><code>indices::Vector{Int}</code>: Sorted indices according to the current population</li><li><code>fronts::Dict{Int,Vector{Int}}</code>: Listing of the pareto front</li></ul><h2 id="Core-Functions"><a class="docs-heading-anchor" href="#Core-Functions">Core Functions</a><a id="Core-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Functions" title="Permalink"></a></h2><h3 id="fit!"><a class="docs-heading-anchor" href="#fit!">fit!</a><a id="fit!-1"></a><a class="docs-heading-anchor-permalink" href="#fit!" title="Permalink"></a></h3><p>Train the GEP regressor model.</p><p>There are multiple overloads for different use cases:</p><ol><li>Standard scalar regression with training data:</li></ol><pre><code class="language-julia hljs">fit!(regressor::GepRegressor, epochs::Int, population_size::Int, x_train::AbstractArray, 
     y_train::AbstractArray; kwargs...)</code></pre><p>Trains using provided data arrays, with optional validation data and dimensional constraints.</p><p><strong>Arguments:</strong></p><ul><li><code>regressor::GepRegressor</code>: The regressor instance</li><li><code>epochs::Int</code>: Number of evolutionary generations</li><li><code>population_size::Int</code>: Size of the population</li><li><code>x_train::AbstractArray</code>: Training features</li><li><code>y_train::AbstractArray</code>: Training targets</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>x_test::Union{AbstractArray,Nothing}=nothing</code>: Test features for validation</li><li><code>y_test::Union{AbstractArray,Nothing}=nothing</code>: Test targets for validation</li><li><code>optimization_epochs::Int=100</code>: Number of epochs for constant optimization</li><li><code>hof::Int=3</code>: Number of best models to keep in hall of fame</li><li><code>loss_fun::Union{String,Function}=&quot;mse&quot;</code>: Loss function (&quot;mse&quot;, &quot;mae&quot;, &quot;rmse&quot; or custom)</li><li><code>loss_fun_validation::Union{String,Function}=&quot;mse&quot;</code>: Validation loss function</li><li><code>correction_epochs::Int=1</code>: Interval for dimensional corrections</li><li><code>correction_amount::Real=0.05</code>: Fraction of population to correct for homogeneity</li><li><code>opt_method_const::Symbol=:cg</code>: Method for constant optimization (:cg, :nd, etc.)</li><li><code>target_dimension::Union{Vector{Float16},Nothing}=nothing</code>: Target physical dimension for homogeneity</li><li><code>cycles::Int=10</code>: Cycles for dimension correction</li><li><code>max_iterations::Int=1000</code>: Max iterations for optimizer</li><li><code>n_starts::Int=3</code>: Number of optimizer restarts</li><li><code>break_condition::Union{Function,Nothing}=nothing</code>: Function to check for early stopping</li><li><code>file_logger_callback::Union{Function,Nothing}=nothing</code>: Callback for logging to file</li><li><code>save_state_callback::Union{Function,Nothing}=nothing</code>: Callback to save evolution state</li><li><code>load_state_callback::Union{Function,Nothing}=nothing</code>: Callback to load evolution state</li><li><code>population_sampling_multiplier::Int=1</code>: Multiplier for initial population sampling</li><li><code>penalty::AbstractFloat=2.0</code>: Penalty factor for duplicate functions</li></ul><ol><li>Custom loss for scalar or multi-objective regression:</li></ol><pre><code class="language-julia hljs">fit!(regressor::GepRegressor, epochs::Int, population_size::Int, loss_function::Function; kwargs...)</code></pre><p>Allows custom loss for guiding evolution, useful for multi-objective or non-standard fitness.</p><p><strong>Arguments:</strong></p><ul><li><code>regressor::GepRegressor</code>: The regressor instance</li><li><code>epochs::Int</code>: Number of generations</li><li><code>population_size::Int</code>: Population size</li><li><code>loss_function::Function</code>: Custom loss function that sets fitness</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>optimizer_function_::Union{Function,Nothing}=nothing</code>: Function for secondary optimization</li><li><code>loss_function_validation::Union{Function,Nothing}=nothing</code>: Validation loss</li><li><code>optimization_epochs::Int=100</code>: Constant optimization epochs</li><li><code>hof::Int=3</code>: Hall of fame size</li><li><code>correction_epochs::Int=1</code>: Dimension correction interval</li><li><code>correction_amount::Real=0.3</code>: Correction fraction</li><li><code>opt_method_const::Symbol=:nd</code>: Constant optimization method</li><li><code>target_dimension::Union{Vector{Float16},Nothing}=nothing</code>: Target dimension</li><li><code>cycles::Int=10</code>: Correction cycles</li><li><code>max_iterations::Int=150</code>: Optimizer iterations</li><li><code>n_starts::Int=5</code>: Optimizer restarts</li><li><code>break_condition::Union{Function,Nothing}=nothing</code>: Early stop condition</li><li><code>file_logger_callback::Union{Function,Nothing}=nothing</code>: Logging callback</li><li><code>save_state_callback::Union{Function,Nothing}=nothing</code>: Save state callback</li><li><code>load_state_callback::Union{Function,Nothing}=nothing</code>: Load state callback</li><li><code>penalty::AbstractFloat=2.0</code>: Duplicate penalty</li></ul><ol><li>For tensor regression:</li></ol><pre><code class="language-julia hljs">fit!(regressor::GepTensorRegressor, epochs::Int, population_size::Int, loss_function::Function; kwargs...)</code></pre><p>Trains tensor regressor with custom tensor-specific loss.</p><p><strong>Arguments:</strong></p><ul><li><code>regressor::GepTensorRegressor</code>: The tensor regressor</li><li><code>epochs::Int</code>: Generations</li><li><code>population_size::Int</code>: Population size</li><li><code>loss_function::Function</code>: Custom tensor loss</li></ul><p><strong>Keyword Arguments:</strong></p><ul><li><code>hof::Int=3</code>: Hall of fame</li><li><code>break_condition::Union{Function,Nothing}=nothing</code>: Stop condition</li><li><code>file_logger_callback::Union{Function,Nothing}=nothing</code>: Logger</li><li><code>save_state_callback::Union{Function,Nothing}=nothing</code>: Save state</li><li><code>load_state_callback::Union{Function,Nothing}=nothing</code>: Load state</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs"># Basic regression
fit!(regressor, 1000, 1000, x_train&#39;, y_train; loss_fun=&quot;mse&quot;)

# With validation data
fit!(regressor, 1000, 1000, x_train&#39;, y_train; 
     x_test=x_test&#39;, y_test=y_test, loss_fun=&quot;rmse&quot;)

# With physical dimensions
fit!(regressor, 1000, 1000, x_train&#39;, y_train; 
     target_dimension=target_dim)

# Tensor regression with custom loss
fit!(regressor, 100, 500, custom_loss_function)</code></pre><h3 id="Prediction"><a class="docs-heading-anchor" href="#Prediction">Prediction</a><a id="Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction" title="Permalink"></a></h3><p>Make predictions using trained regressor.</p><pre><code class="language-julia hljs">(regressor::GepRegressor)(x_data)
(regressor::GepTensorRegressor)(input_data)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>x_data</code>: Input features (features as rows, samples as columns)</li><li><code>input_data</code>: Input data tuple for tensor regression</li></ul><p><strong>Returns:</strong></p><ul><li>Predictions as vector (scalar regression) or vector of tensors (tensor regression)</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs"># Scalar predictions
predictions = regressor(x_test&#39;)

# Tensor predictions
tensor_predictions = tensor_regressor(input_tuple)</code></pre><h3 id="compile_expression!"><a class="docs-heading-anchor" href="#compile_expression!">compile_expression!</a><a id="compile_expression!-1"></a><a class="docs-heading-anchor-permalink" href="#compile_expression!" title="Permalink"></a></h3><p>Compiles chromosome&#39;s genes into executable function using DynamicExpressions.</p><pre><code class="language-julia hljs">compile_expression!(chromosome::Chromosome; force_compile::Bool=false)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>chromosome::Chromosome</code>: Chromosome to compile</li><li><code>force_compile::Bool=false</code>: Force recompilation</li></ul><p><strong>Effects:</strong> Updates chromosome&#39;s <code>compiled_function</code> and related fields.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">compile_expression!(chromosome, force_compile=true)</code></pre><h3 id="fitness"><a class="docs-heading-anchor" href="#fitness">fitness</a><a id="fitness-1"></a><a class="docs-heading-anchor-permalink" href="#fitness" title="Permalink"></a></h3><p>Get chromosome&#39;s fitness value.</p><pre><code class="language-julia hljs">fitness(chromosome::Chromosome)</code></pre><p><strong>Returns:</strong> Fitness value or tuple</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">fit_value = fitness(chromosome)</code></pre><h3 id="set_fitness!"><a class="docs-heading-anchor" href="#set_fitness!">set_fitness!</a><a id="set_fitness!-1"></a><a class="docs-heading-anchor-permalink" href="#set_fitness!" title="Permalink"></a></h3><p>Set chromosome&#39;s fitness value.</p><pre><code class="language-julia hljs">set_fitness!(chromosome::Chromosome, value::Tuple)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>chromosome::Chromosome</code>: Target chromosome</li><li><code>value::Tuple</code>: New fitness value</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">set_fitness!(chromosome, (0.5, 0.3))</code></pre><h3 id="*karva*raw"><a class="docs-heading-anchor" href="#*karva*raw"><em>karva</em>raw</a><a id="*karva*raw-1"></a><a class="docs-heading-anchor-permalink" href="#*karva*raw" title="Permalink"></a></h3><p>Convert a chromosome&#39;s genes into Karva notation (K-expression).</p><pre><code class="language-julia hljs">_karva_raw(chromosome::Chromosome; split::Bool=false)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>chromosome::Chromosome</code>: The chromosome to convert</li><li><code>split::Bool=false</code>: Whether to split the expression by genes</li></ul><p><strong>Returns:</strong> Vector{Int8} representing the K-expression, or list of vectors if split=true</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">k_expression = _karva_raw(chromosome)</code></pre><h3 id="split_karva"><a class="docs-heading-anchor" href="#split_karva">split_karva</a><a id="split_karva-1"></a><a class="docs-heading-anchor-permalink" href="#split_karva" title="Permalink"></a></h3><p>Split a chromosome&#39;s Karva expression into parts.</p><pre><code class="language-julia hljs">split_karva(chromosome::Chromosome, coeffs::Int=2)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>chromosome::Chromosome</code>: The chromosome to process</li><li><code>coeffs::Int=2</code>: Number of parts to split into</li></ul><p><strong>Returns:</strong> List of vectors representing split K-expressions</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">split_expressions = split_karva(chromosome, coeffs=3)</code></pre><h3 id="generate_gene"><a class="docs-heading-anchor" href="#generate_gene">generate_gene</a><a id="generate_gene-1"></a><a class="docs-heading-anchor-permalink" href="#generate_gene" title="Permalink"></a></h3><p>Generate a single gene for GEP.</p><pre><code class="language-julia hljs">generate_gene(headsyms::Vector{Int8}, tailsyms::Vector{Int8}, headlen::Int,
    tail_weights::Weights, head_weights::Weights)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>headsyms::Vector{Int8}</code>: Symbols for head</li><li><code>tailsyms::Vector{Int8}</code>: Symbols for tail</li><li><code>headlen::Int</code>: Head length</li><li><code>tail_weights::Weights</code>: Probability weights for tail symbols</li><li><code>head_weights::Weights</code>: Probability weights for head symbols</li></ul><p><strong>Returns:</strong> Vector{Int8} representing gene</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">gene = generate_gene(headsyms, tailsyms, 5, tail_weights, head_weights)</code></pre><h3 id="generate_chromosome"><a class="docs-heading-anchor" href="#generate_chromosome">generate_chromosome</a><a id="generate_chromosome-1"></a><a class="docs-heading-anchor-permalink" href="#generate_chromosome" title="Permalink"></a></h3><p>Generate a new chromosome using toolbox configuration.</p><pre><code class="language-julia hljs">generate_chromosome(toolbox::Toolbox)</code></pre><p><strong>Parameters:</strong></p><ul><li><code>toolbox::Toolbox</code>: Toolbox configuration</li></ul><p><strong>Returns:</strong> New Chromosome instance</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">chromosome = generate_chromosome(toolbox)</code></pre><h3 id="perform_step!"><a class="docs-heading-anchor" href="#perform_step!">perform_step!</a><a id="perform_step!-1"></a><a class="docs-heading-anchor-permalink" href="#perform_step!" title="Permalink"></a></h3><p>Performs one evolutionary step in the GEP algorithm, creating and evaluating new chromosomes.</p><pre><code class="language-julia hljs">perform_step!(population::Vector{Chromosome}, parents::Vector{Chromosome}, 
    next_gen::Vector{Chromosome}, toolbox::Toolbox, mating_size::Int)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>population::Vector{Chromosome}</code>: Current population of chromosomes</li><li><code>parents::Vector{Chromosome}</code>: Selected parent chromosomes for breeding</li><li><code>next_gen::Vector{Chromosome}</code>: Buffer for storing newly created chromosomes</li><li><code>toolbox::Toolbox</code>: Contains genetic operators and algorithm parameters</li><li><code>mating_size::Int</code>: Number of chromosomes to create in this step</li></ul><p><strong>Details:</strong></p><ul><li>Processes parents in pairs to create new chromosomes</li><li>Applies genetic operations to create offspring</li><li>Compiles expressions for new chromosomes</li><li>Updates population with new chromosomes</li><li>Operations are performed in parallel using multiple threads</li></ul><h3 id="perform*correction*callback!"><a class="docs-heading-anchor" href="#perform*correction*callback!">perform<em>correction</em>callback!</a><a id="perform*correction*callback!-1"></a><a class="docs-heading-anchor-permalink" href="#perform*correction*callback!" title="Permalink"></a></h3><p>Applies correction operations to ensure dimensional homogeneity in chromosomes.</p><pre><code class="language-julia hljs">perform_correction_callback!(population::Vector{Chromosome}, epoch::Int, 
    correction_epochs::Int, correction_amount::Real,
    correction_callback::Union{Function,Nothing})</code></pre><p><strong>Arguments:</strong></p><ul><li><code>population::Vector{Chromosome}</code>: Current population of chromosomes</li><li><code>epoch::Int</code>: Current epoch number</li><li><code>correction_epochs::Int</code>: Frequency of correction operations</li><li><code>correction_amount::Real</code>: Proportion of population to apply corrections to</li><li><code>correction_callback::Union{Function,Nothing}</code>: Function that performs the actual correction</li></ul><p><strong>Details:</strong></p><ul><li>Executes corrections periodically (every correction_epochs)</li><li>Processes a subset of the population determined by correction_amount</li><li>Applies corrections to dimensionally heterogeneous chromosomes</li><li>Updates chromosome compilation and dimensional homogeneity flags</li></ul><h3 id="runGep"><a class="docs-heading-anchor" href="#runGep">runGep</a><a id="runGep-1"></a><a class="docs-heading-anchor-permalink" href="#runGep" title="Permalink"></a></h3><p>Main function that executes the GEP algorithm using a specified evaluation strategy.</p><pre><code class="language-julia hljs">runGep(epochs::Int, population_size::Int, toolbox::Toolbox, evalStrategy::EvaluationStrategy;
    hof::Int=3, correction_callback::Union{Function,Nothing}=nothing,
    correction_epochs::Int=1, correction_amount::Real=0.6,
    tourni_size::Int=3)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>epochs::Int</code>: Number of evolutionary epochs to run</li><li><code>population_size::Int</code>: Size of the chromosome population</li><li><code>toolbox::Toolbox</code>: Contains genetic operators and algorithm parameters</li><li><code>evalStrategy::EvaluationStrategy</code>: Strategy for evaluating chromosomes, handling fitness computation, and optimization</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>hof::Int=3</code>: Number of best solutions to return (Hall of Fame size)</li><li><code>correction_callback::Union{Function,Nothing}=nothing</code>: Function for dimensional homogeneity correction</li><li><code>correction_epochs::Int=1</code>: Frequency of correction operations</li><li><code>correction_amount::Real=0.6</code>: Proportion of population for correction</li><li><code>tourni_size::Int=3</code>: Tournament selection size</li><li><code>file_logger_callback::Union{Function,Nothing}=nothing</code>: Callback for extra logging, expected inputs <code>file_logger_callback(population::Vector{Chromosome}, epoch::Int, selectedMembers::SelectedMembers)</code></li><li><code>save_state_callback::Union{Function,Nothing}=nothing</code>: Callback for save a population, expected inputs <code>save_state_callback(population::Vector{Chromosome},evalStrategy::EvaluationStrategy)</code></li><li><code>load_state_callback::Union{Function,Nothing}=nothing</code>: Callback for loading a population, expected return <code>tuple(population::Vector{Chromosome},startepoch::Int)</code></li><li><code>population_sampling_multiplier::Int=100</code>: Expansionfactor on the population to employ Latin-Hypercupe</li><li><code>cache_size::Int=10000</code>: Functions stored in cache, (Limit! To mitigate cache blow up)</li><li><code>penalty::AbstractFloat=2.0</code>: Employs a fit penalty for functions that has been seen for the second time</li></ul><p><strong>Returns:</strong> <code>Tuple{Vector{Chromosome}, Any}</code>: Returns best solutions and training history</p><p><strong>Details:</strong></p><ol><li>Initializes population and evolution parameters</li><li>For each epoch:<ul><li>Applies dimensional homogeneity corrections if provided</li><li>Computes fitness for all chromosomes using evaluation strategy</li><li>Sorts population based on fitness</li><li>Applies secondary optimization if specified in strategy</li><li>Records training progress</li><li>Checks break condition from evaluation strategy</li><li>Performs selection and creates new generation</li></ul></li><li>Returns final solutions and training history</li></ol><p>Progress is monitored through a progress bar showing:</p><ul><li>Current epoch</li><li>Training loss</li><li>Validation loss</li></ul><p>The evolution process stops when either:</p><ul><li>Maximum epochs is reached</li><li>Break condition specified in evaluation strategy is met =&gt; needs to be informed as break_condition(population, epoch)</li></ul><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><h3 id="Data-Utilities"><a class="docs-heading-anchor" href="#Data-Utilities">Data Utilities</a><a id="Data-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Utilities" title="Permalink"></a></h3><h4 id="train*test*split"><a class="docs-heading-anchor" href="#train*test*split">train<em>test</em>split</a><a id="train*test*split-1"></a><a class="docs-heading-anchor-permalink" href="#train*test*split" title="Permalink"></a></h4><pre><code class="language-julia hljs">train_test_split(X, y; test_ratio=0.2, random_state=42)</code></pre><p>Split data into training and testing sets.</p><p><strong>Parameters:</strong></p><ul><li><code>X</code>: Feature matrix</li><li><code>y</code>: Target vector</li><li><code>test_ratio::Float64 = 0.2</code>: Proportion of data for testing</li><li><code>random_state::Int = 42</code>: Random seed</li></ul><p><strong>Returns:</strong></p><ul><li><code>(X_train, X_test, y_train, y_test)</code>: Split data</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">X_train, X_test, y_train, y_test = train_test_split(X, y; test_ratio=0.3)</code></pre><h3 id="Expression-Utilities"><a class="docs-heading-anchor" href="#Expression-Utilities">Expression Utilities</a><a id="Expression-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Utilities" title="Permalink"></a></h3><h4 id="print*karva*strings"><a class="docs-heading-anchor" href="#print*karva*strings">print<em>karva</em>strings</a><a id="print*karva*strings-1"></a><a class="docs-heading-anchor-permalink" href="#print*karva*strings" title="Permalink"></a></h4><pre><code class="language-julia hljs">print_karva_strings(chromosome::Chromosome; split_len::Int=1)</code></pre><p>Print the Karva notation representation of a chromosome.</p><p><strong>Parameters:</strong></p><ul><li><code>chromosome::Chromosome</code>: Chromosome to print</li><li><code>split_len::Int=1</code>: Length for splitting output</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">print_karva_strings(chromosome)</code></pre><h3 id="optimize_constants!"><a class="docs-heading-anchor" href="#optimize_constants!">optimize_constants!</a><a id="optimize_constants!-1"></a><a class="docs-heading-anchor-permalink" href="#optimize_constants!" title="Permalink"></a></h3><p>Optimizes constant values in a symbolic expression tree to minimize a given loss function.</p><pre><code class="language-julia hljs">optimize_constants!(
    node::Node,
    loss::Function;
    opt_method::Symbol=:cg,
    max_iterations::Int=250,
    n_restarts::Int=3
)</code></pre><p><strong>Arguments:</strong></p><ul><li><code>node::Node</code>: Expression tree containing constants to optimize</li><li><code>loss::Function</code>: Loss function to minimize</li><li><code>opt_method::Symbol=:cg</code>: Optimization method (:newton, :cg, or other for NelderMead)</li><li><code>max_iterations::Int=250</code>: Maximum iterations per optimization attempt</li><li><code>n_restarts::Int=3</code>: Number of random restarts to avoid local minima</li></ul><p><strong>Returns:</strong> Tuple containing:</p><ul><li><code>best_node::Node</code>: Expression tree with optimized constants</li><li><code>best_loss::Float64</code>: Final loss value achieved</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs"># Create expression with constants
expr = Node(*, [
    Node(1.5),  # constant to optimize
    Node(x, degree=1)  # variable
])

# Define loss function
loss(node) = sum((node(x_data) .- y_data).^2)

# Optimize constants
optimized_expr, final_loss = optimize_constants!(
    expr,
    loss;
    opt_method=:cg,
    max_iterations=500,
    n_restarts=5
)</code></pre><h2 id="Loss-Functions"><a class="docs-heading-anchor" href="#Loss-Functions">Loss Functions</a><a id="Loss-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Loss-Functions" title="Permalink"></a></h2><h3 id="Built-in-Loss-Functions"><a class="docs-heading-anchor" href="#Built-in-Loss-Functions">Built-in Loss Functions</a><a id="Built-in-Loss-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-Loss-Functions" title="Permalink"></a></h3><p>The package provides several built-in loss functions accessible via string names:</p><h4 id="&quot;mse&quot;-Mean-Squared-Error"><a class="docs-heading-anchor" href="#&quot;mse&quot;-Mean-Squared-Error">&quot;mse&quot; - Mean Squared Error</a><a id="&quot;mse&quot;-Mean-Squared-Error-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;mse&quot;-Mean-Squared-Error" title="Permalink"></a></h4><pre><code class="language-julia hljs">mse(y_true, y_pred) = mean((y_true .- y_pred).^2)</code></pre><h4 id="&quot;mae&quot;-Mean-Absolute-Error"><a class="docs-heading-anchor" href="#&quot;mae&quot;-Mean-Absolute-Error">&quot;mae&quot; - Mean Absolute Error</a><a id="&quot;mae&quot;-Mean-Absolute-Error-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;mae&quot;-Mean-Absolute-Error" title="Permalink"></a></h4><pre><code class="language-julia hljs">mae(y_true, y_pred) = mean(abs.(y_true .- y_pred))</code></pre><h4 id="&quot;rmse&quot;-Root-Mean-Squared-Error"><a class="docs-heading-anchor" href="#&quot;rmse&quot;-Root-Mean-Squared-Error">&quot;rmse&quot; - Root Mean Squared Error</a><a id="&quot;rmse&quot;-Root-Mean-Squared-Error-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;rmse&quot;-Root-Mean-Squared-Error" title="Permalink"></a></h4><pre><code class="language-julia hljs">rmse(y_true, y_pred) = sqrt(mean((y_true .- y_pred).^2))</code></pre><h3 id="Custom-Loss-Functions"><a class="docs-heading-anchor" href="#Custom-Loss-Functions">Custom Loss Functions</a><a id="Custom-Loss-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Loss-Functions" title="Permalink"></a></h3><p>For advanced applications, you can define custom loss functions:</p><h4 id="Single-Objective-Custom-Loss"><a class="docs-heading-anchor" href="#Single-Objective-Custom-Loss">Single-Objective Custom Loss</a><a id="Single-Objective-Custom-Loss-1"></a><a class="docs-heading-anchor-permalink" href="#Single-Objective-Custom-Loss" title="Permalink"></a></h4><pre><code class="language-julia hljs">function custom_loss(y_true, y_pred)
    # Your custom loss calculation
    return loss_value::Float64
end

# Use with fit!
fit!(regressor, epochs, population_size, x_data&#39;, y_data; loss_fun=custom_loss)</code></pre><h4 id="Multi-Objective-Custom-Loss"><a class="docs-heading-anchor" href="#Multi-Objective-Custom-Loss">Multi-Objective Custom Loss</a><a id="Multi-Objective-Custom-Loss-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Objective-Custom-Loss" title="Permalink"></a></h4><pre><code class="language-julia hljs">@inline function multi_objective_loss(elem, validate::Bool)
    if isnan(mean(elem.fitness)) || validate
        model = elem.compiled_function
        
        try
            y_pred = model(x_data&#39;)
            
            # Objective 1: Accuracy
            mse = mean((y_true .- y_pred).^2)
            
            # Objective 2: Complexity
            complexity = expression_complexity(model) # expression complexity needs to be defined by the user
            
            elem.fitness = (mse, complexity)
        catch
            elem.fitness = (typemax(Float64), typemax(Float64))
        end
    end
end

# Use with multi-objective regressor
regressor = GepRegressor(n_features; number_of_objectives=2)
fit!(regressor, epochs, population_size, multi_objective_loss)</code></pre><h4 id="Tensor-Custom-Loss"><a class="docs-heading-anchor" href="#Tensor-Custom-Loss">Tensor Custom Loss</a><a id="Tensor-Custom-Loss-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Custom-Loss" title="Permalink"></a></h4><pre><code class="language-julia hljs">@inline function tensor_loss(elem, validate::Bool)
    if isnan(mean(elem.fitness)) || validate
        model = elem.compiled_function
        
        try
            predictions = model(input_data)
            
            # Calculate tensor-specific loss
            total_error = 0.0
            for i in 1:length(target_tensors)
                error = norm(predictions[i] - target_tensors[i])^2
                total_error += error
            end
            
            elem.fitness = (total_error / length(target_tensors),)
        catch
            elem.fitness = (typemax(Float64),)
        end
    end
end</code></pre><h4 id="Template-loss"><a class="docs-heading-anchor" href="#Template-loss">Template loss</a><a id="Template-loss-1"></a><a class="docs-heading-anchor-permalink" href="#Template-loss" title="Permalink"></a></h4><p>Template loss enables multiexpression formulation or fixed defined template functions like <span>$f(x_1,..x_n)=v(x_1,x_2) + g(x_3)$</span>. </p><pre><code class="language-julia hljs">@inline function loss_new(elem, validate::Bool)
    try
        if isnan(mean(elem.fitness)) || validate

            g1 = elem.compiled_function[1](x_data&#39;, regressor.operators_)
            g2 = elem.compiled_function[2](x_data&#39;, regressor.operators_)

            a_pred = @. (g1&#39; * t1) + (g2&#39; * t2)
            loss = abs(norm(a_true - a_pred))
            elem.fitness = (loss,)
        end
    catch e
        @error &quot;something wnt wrong&quot; exception = (e, catch_backtrace())
        elem.fitness = (typemax(Float64),)
    end
end</code></pre><h2 id="Selection-Methods"><a class="docs-heading-anchor" href="#Selection-Methods">Selection Methods</a><a id="Selection-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-Methods" title="Permalink"></a></h2><h3 id="Tournament-Selection"><a class="docs-heading-anchor" href="#Tournament-Selection">Tournament Selection</a><a id="Tournament-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Tournament-Selection" title="Permalink"></a></h3><p>Default selection method that chooses the best individual based on tournament selections.</p><p><strong>Configuration:</strong></p><pre><code class="language-julia hljs">regressor = GepRegressor(n_features)</code></pre><h3 id="NSGA-II-Selection"><a class="docs-heading-anchor" href="#NSGA-II-Selection">NSGA-II Selection</a><a id="NSGA-II-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#NSGA-II-Selection" title="Permalink"></a></h3><p>Multi-objective selection using Non-dominated Sorting Genetic Algorithm II.</p><p><strong>Configuration:</strong></p><pre><code class="language-julia hljs">regressor = GepRegressor(n_features; 
                        number_of_objectives=2)</code></pre><h2 id="Genetic-Operators"><a class="docs-heading-anchor" href="#Genetic-Operators">Genetic Operators</a><a id="Genetic-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Genetic-Operators" title="Permalink"></a></h2><h3 id="Genetic-Operators-2"><a class="docs-heading-anchor" href="#Genetic-Operators-2">Genetic Operators</a><a class="docs-heading-anchor-permalink" href="#Genetic-Operators-2" title="Permalink"></a></h3><p>The package implements several genetic operators. These can be adjusted in advance using the dictionary <code>GENE_COMMON_PROBS</code>, which is available after loading the <code>GeneExpressionProgramming.jl</code></p><ul><li><strong>Point Mutation</strong>: Random symbol replacement</li><li><strong>Inversion</strong>: Sequence reversal</li><li><strong>IS Transposition</strong>: Insertion sequence transposition</li><li><strong>RIS Transposition</strong>: Root insertion sequence transposition</li></ul><p><strong>Configuration:</strong></p><pre><code class="language-julia hljs">using GeneExpressionProgramming

GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;mutation_prob&quot;] = 1.0 # Probability for a chromosome of facing a mutation
GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;mutation_rate&quot;] = 0.1 # Proportion of the gene being changed

GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;inversion_prob&quot;] = 0.1 # Setting the prob. for the operation to take place 
GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;insertion_prob&quot;] = 0.1 # Setting IS 
GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;root_insertion_prob&quot;] = 0.1 # Setting RIS
GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;gene_transposition&quot;] = 0.0  # Setting Transposition</code></pre><h3 id="Crossover-Operators"><a class="docs-heading-anchor" href="#Crossover-Operators">Crossover Operators</a><a id="Crossover-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Crossover-Operators" title="Permalink"></a></h3><p>Available crossover operators:</p><ul><li><strong>One-Point Crossover</strong>: Single crossover point</li><li><strong>Two-Point Crossover</strong>: Two crossover points</li></ul><p><strong>Configuration:</strong></p><pre><code class="language-julia hljs">using GeneExpressionProgramming

GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;one_point_cross_over_prob&quot;] = 0.5 # Setting the one-point crossover
GeneExpressionProgramming.RegressionWrapper.GENE_COMMON_PROBS[&quot;two_point_cross_over_prob&quot;] = 0.3 # Setting the two-point crossover</code></pre><h2 id="Function-Sets"><a class="docs-heading-anchor" href="#Function-Sets">Function Sets</a><a id="Function-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Sets" title="Permalink"></a></h2><h3 id="Basic-Arithmetic"><a class="docs-heading-anchor" href="#Basic-Arithmetic">Basic Arithmetic</a><a id="Basic-Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Arithmetic" title="Permalink"></a></h3><pre><code class="language-julia hljs">basic_functions = [:+, :-, :*, :/]</code></pre><h3 id="Extended-Mathematical-Functions"><a class="docs-heading-anchor" href="#Extended-Mathematical-Functions">Extended Mathematical Functions</a><a id="Extended-Mathematical-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Mathematical-Functions" title="Permalink"></a></h3><pre><code class="language-julia hljs">extended_functions = [:+, :-, :*, :/, :sin, :cos, :tan, :exp, :log, :sqrt, :abs]</code></pre><h3 id="Power-Functions"><a class="docs-heading-anchor" href="#Power-Functions">Power Functions</a><a id="Power-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Functions" title="Permalink"></a></h3><pre><code class="language-julia hljs">power_functions = [:^, :sqrt]</code></pre><h3 id="Trigonometric-Functions"><a class="docs-heading-anchor" href="#Trigonometric-Functions">Trigonometric Functions</a><a id="Trigonometric-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Trigonometric-Functions" title="Permalink"></a></h3><pre><code class="language-julia hljs">trig_functions = [:sin, :cos, :tan, :asin, :acos, :atan, :sinh, :cosh, :tanh]</code></pre><h2 id="Physical-Dimensionality"><a class="docs-heading-anchor" href="#Physical-Dimensionality">Physical Dimensionality</a><a id="Physical-Dimensionality-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Dimensionality" title="Permalink"></a></h2><h3 id="Dimension-Representation"><a class="docs-heading-anchor" href="#Dimension-Representation">Dimension Representation</a><a id="Dimension-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension-Representation" title="Permalink"></a></h3><p>Physical dimensions are represented as 7-element vectors corresponding to SI base units:</p><pre><code class="language-julia hljs"># [Mass, Length, Time, Temperature, Current, Amount, Luminosity]
velocity_dim = Float16[0, 1, -1, 0, 0, 0, 0]    # [L T⁻¹]
force_dim = Float16[1, 1, -2, 0, 0, 0, 0]       # [M L T⁻²]
energy_dim = Float16[1, 2, -2, 0, 0, 0, 0]      # [M L² T⁻²]</code></pre><h3 id="Dimensional-Constraints"><a class="docs-heading-anchor" href="#Dimensional-Constraints">Dimensional Constraints</a><a id="Dimensional-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Dimensional-Constraints" title="Permalink"></a></h3><pre><code class="language-julia hljs">feature_dims = Dict{Symbol,Vector{Float16}}(
    :x1 =&gt; Float16[1, 0, 0, 0, 0, 0, 0],    # Mass
    :x2 =&gt; Float16[0, 1, 0, 0, 0, 0, 0],    # Length
    :x3 =&gt; Float16[0, 0, 1, 0, 0, 0, 0],    # Time
)

target_dim = Float16[0, 1, -1, 0, 0, 0, 0]  # Velocity

regressor = GepRegressor(3; 
                        considered_dimensions=feature_dims,
                        max_permutations_lib=10000)

fit!(regressor, epochs, population_size, x_data&#39;, y_data; 
     target_dimension=target_dim)</code></pre><h2 id="Tensor-Operations-(under-construction)"><a class="docs-heading-anchor" href="#Tensor-Operations-(under-construction)">Tensor Operations (under construction)</a><a id="Tensor-Operations-(under-construction)-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Operations-(under-construction)" title="Permalink"></a></h2><h3 id="Supported-Tensor-Types"><a class="docs-heading-anchor" href="#Supported-Tensor-Types">Supported Tensor Types</a><a id="Supported-Tensor-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Tensor-Types" title="Permalink"></a></h3><p>The tensor regression module supports various tensor types through Tensors.jl:</p><pre><code class="language-julia hljs">using Tensors

# Vectors (rank-1 tensors)
vector_3d = rand(Tensor{1,3})

# Matrices (rank-2 tensors)  
matrix_2x2 = rand(Tensor{2,2})

# Higher-order tensors
tensor_3x3x3 = rand(Tensor{3,3})</code></pre><h3 id="Tensor-Operations"><a class="docs-heading-anchor" href="#Tensor-Operations">Tensor Operations</a><a id="Tensor-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Operations" title="Permalink"></a></h3><p>Available tensor operations include:</p><ul><li><strong>Element-wise operations</strong>: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li><li><strong>Tensor products</strong>: <code>⊗</code> (outer product)</li><li><strong>Contractions</strong>: <code>⋅</code> (dot product), <code>⊡</code> (double contraction)</li><li><strong>Norms</strong>: <code>norm()</code>, <code>tr()</code> (trace)</li><li><strong>Decompositions</strong>: <code>eigen()</code>, <code>svd()</code></li></ul><h2 id="Error-Handling"><a class="docs-heading-anchor" href="#Error-Handling">Error Handling</a><a id="Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling" title="Permalink"></a></h2><h3 id="Common-Error"><a class="docs-heading-anchor" href="#Common-Error">Common Error</a><a id="Common-Error-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Error" title="Permalink"></a></h3><h4 id="ArgumentError:-collection-must-be-non-empty"><a class="docs-heading-anchor" href="#ArgumentError:-collection-must-be-non-empty">ArgumentError: collection must be non-empty</a><a id="ArgumentError:-collection-must-be-non-empty-1"></a><a class="docs-heading-anchor-permalink" href="#ArgumentError:-collection-must-be-non-empty" title="Permalink"></a></h4><p>Thrown when the argument vector for the selection process is empty. This happens when all the loss returns <code>Inf</code> for all fit values.</p><h2 id="Performance-Tuning"><a class="docs-heading-anchor" href="#Performance-Tuning">Performance Tuning</a><a id="Performance-Tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tuning" title="Permalink"></a></h2><h3 id="Memory-Management"><a class="docs-heading-anchor" href="#Memory-Management">Memory Management</a><a id="Memory-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Management" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Monitor memory usage
using Profile

@profile fit!(regressor, epochs, population_size, x_data&#39;, y_data)
Profile.print()

# Force garbage collection
GC.gc()</code></pre><h2 id="Configuration-Examples"><a class="docs-heading-anchor" href="#Configuration-Examples">Configuration Examples</a><a id="Configuration-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-Examples" title="Permalink"></a></h2><h3 id="Basic-Configuration"><a class="docs-heading-anchor" href="#Basic-Configuration">Basic Configuration</a><a id="Basic-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">regressor = GepRegressor(3)
fit!(regressor, 1000, 1000, x_data&#39;, y_data)</code></pre><h3 id="Advanced-Configuration"><a class="docs-heading-anchor" href="#Advanced-Configuration">Advanced Configuration</a><a id="Advanced-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">regressor = GepRegressor(
    5;                                    # 5 input features
    population_size = 2000,               # Large population
    gene_count = 3,                       # 3 genes per chromosome
    head_len = 8,                         # Longer expressions
    entered_non_terminals = [:+, :-, :*, :/, :sin, :cos, :exp]
)

fit!(regressor, 1500, 2000, x_train&#39;, y_train;
     x_test = x_test&#39;, 
     y_test = y_test,
     loss_fun = &quot;rmse&quot;)</code></pre><h3 id="Multi-Objective-Configuration"><a class="docs-heading-anchor" href="#Multi-Objective-Configuration">Multi-Objective Configuration</a><a id="Multi-Objective-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-Objective-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">regressor = GepRegressor(
    3;
    number_of_objectives = 2,
    population_size = 1500,
    gene_count = 2,
    head_len = 6
)

fit!(regressor, 1000, 1500, loss_function=multi_objective_loss)</code></pre><h3 id="Physical-Dimensionality-Configuration"><a class="docs-heading-anchor" href="#Physical-Dimensionality-Configuration">Physical Dimensionality Configuration</a><a id="Physical-Dimensionality-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-Dimensionality-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">feature_dims = Dict{Symbol,Vector{Float16}}(
    :x1 =&gt; Float16[1, 0, 0, 0, 0, 0, 0],  # Mass
    :x2 =&gt; Float16[0, 1, 0, 0, 0, 0, 0],  # Length
    :x3 =&gt; Float16[0, 0, 1, 0, 0, 0, 0],  # Time
)

regressor = GepRegressor(
    3;
    considered_dimensions = feature_dims,
    max_permutations_lib = 15000,
    rounds = 8
)

target_dim = Float16[1, 1, -2, 0, 0, 0, 0]  # Force

fit!(regressor, 1200, 1200, x_data&#39;, y_data;
     target_dimension = target_dim)</code></pre><h3 id="Tensor-Regression-Configuration"><a class="docs-heading-anchor" href="#Tensor-Regression-Configuration">Tensor Regression Configuration</a><a id="Tensor-Regression-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Regression-Configuration" title="Permalink"></a></h3><pre><code class="language-julia hljs">regressor = GepTensorRegressor(
    5,                                    # 5 features
    gene_count = 2,                       # Number of genes
    head_len = 5,                         # Head length for each gene
    feature_names = [&quot;scalar1&quot;, &quot;scalar2&quot;, &quot;vector1&quot;, &quot;vector2&quot;, &quot;matrix1&quot;]
)

fit!(regressor, 150, 800, tensor_loss_function)</code></pre><h2 id="Version-Information"><a class="docs-heading-anchor" href="#Version-Information">Version Information</a><a id="Version-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Version-Information" title="Permalink"></a></h2><pre><code class="language-julia hljs"># Get package version
using Pkg
Pkg.status(&quot;GeneExpressionProgramming&quot;)

# Check for updates
Pkg.update(&quot;GeneExpressionProgramming&quot;)</code></pre><h2 id="Debugging-and-Diagnostics"><a class="docs-heading-anchor" href="#Debugging-and-Diagnostics">Debugging and Diagnostics</a><a id="Debugging-and-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Debugging-and-Diagnostics" title="Permalink"></a></h2><h3 id="Fitness-History"><a class="docs-heading-anchor" href="#Fitness-History">Fitness History</a><a id="Fitness-History-1"></a><a class="docs-heading-anchor-permalink" href="#Fitness-History" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Access fitness evolution
if hasfield(typeof(regressor), :fitness_history_)
    history = regressor.fitness_history_
    train_loss = [elem[1] for elem in history.train_loss]
    plot(train_loss)
end</code></pre><h3 id="Expression-Analysis"><a class="docs-heading-anchor" href="#Expression-Analysis">Expression Analysis</a><a id="Expression-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Analysis" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Analyze best expressions
for (i, model) in enumerate(regressor.best_models_)
    println(&quot;Model $i: $(model.compiled_function)&quot;)
    println(&quot;Fitness: $(model.fitness)&quot;)
end</code></pre><p>This API reference provides comprehensive coverage of all public interfaces in GeneExpressionProgramming.jl. For additional examples and use cases, refer to the <a href="./examples/">Examples</a>.</p><hr/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples/tensor-regression.html">« Tensor Regression</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 15 August 2025 11:48">Friday 15 August 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
